# -*- mode:ruby encoding:UTF-8 -*-
# jedit: :mode=ruby:

#  Groovy -- A native launcher for Groovy
#
#  Copyright Â© 2006-7 Russel Winder
#
#  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
#  compliance with the License. You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software distributed under the License is
#  distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
#  implied. See the License for the specific language governing permissions and limitations under the
#  License.
#
#  Author : Russel Winder <russel@russel.org.uk>
#  $Revision$
#  $Date$

import 'c/dependencies'

if [ CYGWIN , MSYS , WINDOWS ].include?( Environment[ 'Architecture' ] ) then Environment[ 'Name' ] += '.exe' end

BuildBaseDirectory = Environment[ 'BuildDirectory' ]

ObjectsDirectory = '../' + BuildBaseDirectory + '/objects'
Executable = '../' + BuildBaseDirectory + '/' + Environment[ 'Name' ]
Sources = sys[ '*.c' ]

javaHome = ENV[ 'JAVA_HOME' ]
if javaHome == nil || javaHome == ''
  if Environment[ 'Architecture' ] == MAC_OS_X
    putativeDirectory = '/System/Library/Frameworks/JavaVM.framework'
    if File.directory?( putativeDirectory ) then javaHome = putativeDirectory
    else raise "JAVA_HOME not defined and #{putativeDirectory} not found."
    end
  else
    raise 'JAVA_HOME not defined.'
  end
end

if Environment[ 'Architecture' ] == CYGWIN
  javaHome = ( `cygpath --unix "#{javaHome}"` ).strip( )
end

# Assume a default of GCC since most of the systems we are checking use this.

$gcc = 'gcc'
$cppFlags = "-I'#{javaHome}/include/#{Environment[ 'Architecture' ]}' -I'#{javaHome}/include'"
$cFlags = '-O3 -W -Wall -Wundef -Wcast-align -Wno-unused-parameter -Wshadow -Wredundant-decls'
$libs = '-ldl'

def compileCommand( target , sources ) ; "#{$gcc} #{$debug ? '-g' : ''} #{$cppFlags} #{$cFlags} -c -o #{target} #{sources}" end
def linkCommand( target , sources ) ; "#{$gcc} #{$debug ? '-g' : ''} #{$cFlags} -o #{target} #{sources} #{$libs}" end

case Environment[ 'Architecture' ]
when MAC_OS_X
  $cppFlags += " -I'#{javaHome}/Headers'"
when CYGWIN
  # TODO: do the object files really need to be compiled w/ -mwindows or is it sufficient to use that option just when linking?
  # A quote from the cygwin manual:
  # If you are writing a GUI program, you should either compile with -mwindows as explained above, or add the string "-Wl,--subsystem,windows" to the GCC command line.
  # http://cygwin.com/faq/faq.programming.html#faq.programming.no-console-window
  # At least w/ ms compiler and linker, only the linker needs to know whether we are producing a gui or console app, so I would believe it's the same here.
  $libs = ''
  $cFlags += ' -s -mno-cygwin' # + ' -D_cwcompat'
  $cppFlags = "-I\"#{javaHome}/include/win32\" -I\"#{javaHome}/include\""
  def compileCommand( target , sources ) ; "#{$gcc} #{$debug ? '-g' : ''} #{$cppFlags} #{$cFlags} -c -o #{target} #{sources}" end
  def linkCommand( target , sources ) ; "#{$gcc} #{$debug ? '-g' : ''} #{if target =~ /w\.exe$/ then '-mwindows' end} #{$cFlags} -o #{target} #{sources} #{$libs}" end
when MSYS
  $libs = ''
  $cppFlags = "-I\"#{javaHome}\\include\\win32\" -I\"#{javaHome}\\include\""
when WINDOWS
  $gcc = 'cl'
  
  # -Wall produces screenfulls of useless warnings about win header files unless the following warnings are omitted:
  # c4255 == 'function' : no function prototype given: converting '()' to '(void)'
  # c4668 == 'symbol' is not defined as a preprocessor macro, replacing with '0' for 'directives'
  # c4820 == padding added into a struct 
  # This one is disabled as there's a lot of this done intentionally (and there seems to be no way to tell cl that it's intentional):
  # c4706 == assignment in conditional expression
  # this one's disabled as it does not seem very interesting:
  # c4711 == function 'function' selected for inline expansion
  
  # the -MD option is important - it is required when using JNI. 
  # See e.g. http://java.sun.com/docs/books/jni/html/start.html#27008 and
  #          http://java.sun.com/docs/books/jni/html/invoke.html#28755
  
  # the -O1 is there just to reduce the size of the executable - it is not mandatory
  
  $cppFlags = "-nologo -c -MD -I #{javaHome}\\include -I #{javaHome}\\include\\win32"
  #$cppFlags += ' -D_cwcompat'
  def compileCommand( target , sources)
    "#{$gcc} #{$debug ? '-Zi' : '-O1'} -Wall -wd4255 -wd4668 -wd4706 -wd4711 -wd4820 -Fo#{target} #{$cppFlags} #{sources}"
  end
  def linkCommand( target , sources )
    windowsApp = ( target =~ /w\.exe$/ )    
    "link #{'-debug ' if $debug}-nologo #{windowsApp ? '-subsystem:windows -entry:mainCRTStartup' : '-subsystem:console'} -out:#{target} #{sources}"
  end
end 

def object( source ) ; ObjectsDirectory + '/' + source.sub( '.c' , '.o' ) end

executablePrerequisites = Sources.map { | source | object( source ) }
defaultTasks = [ :initialize , Executable ]
resFile = nil

if [ WINDOWS , MSYS , CYGWIN ].include?( Environment[ 'Architecture' ] )
  IsWindows = ( Environment[ 'Architecture' ] == WINDOWS ) 
  resFile = ObjectsDirectory + "/groovy.#{IsWindows ? 'res' : 'coff'}"
  file resFile => [ 'groovy.rc' ] do | target |
    sys.sh( IsWindows ? "rc -fo #{target.name} #{target.prerequisites}" : "windres #{target.prerequisites} -O coff #{target.name} " )
  end
  executablePrerequisites << resFile
  Executable_W = Executable.gsub( /\.exe$/ , 'w.exe' )  
  defaultTasks << Executable_W 
  
  # Rant has a problem which is a deep combination of sys globbing, use of map on the result and then using
  # the array in two separate file rules.  Workaround for now is to duplicate.
  
  file Executable_W => executablePrerequisites.dup do | target |
    sys.sh( linkCommand( target.name , target.prerequisites ) )
  end
end

file Executable => executablePrerequisites do | target |
  sys.sh( linkCommand( target.name , target.prerequisites ) )
end

Sources.each { | source |
  file object( source ) => source do | target | 
    sys.sh( compileCommand( target.name , target.prerequisites ) ) 
  end
}

task :initialize do
  if ! File.directory?( ObjectsDirectory ) then sys.mkdir_p( ObjectsDirectory ) end
  DependenciesFile = ObjectsDirectory + '/dependencies'
  gen C::Dependencies , DependenciesFile , :search => 'source'
  gen Action do source DependenciesFile end
end

task :compile => defaultTasks 

task :set_debug do $debug = true end
task :debug => [ :set_debug ] + defaultTasks 

task :default => :compile
